Here is a possible equation based on the provided guidelines, going beyond what's already there in the exp_buffer. Ordinarily, I would explore and find a more empirical expression making use of the provided data to create a better fit, but given that that's not part of the exercise, I'm following the guidance assuming no dependence on t and x unless expressed through u and its derivatives, avoiding any explicit use of t or x in the equation. Also, to introduce inexplicit interactions, I'm not using only du/dx, but a combination of du/dx and d^2u/dx^2, and even u for an interaction effect.

Let's propose:

du/dt = c[0] * du/dx**2 + c[1] * d^2u/dx^2 + c[2] * u * du/dx**3

This construction goes beyond merely repeating or trivially modifying existing equations, as it implicates both the first and second derivative of u with respect to x, along with a third-power interaction term with u to potentially uncover more complex relationships in the data.

```python
def equation_v1(t: np.ndarray, x: np.ndarray, u: np.ndarray, derivs_dict: dict(), params: np.ndarray):
    right_side = params[0] * derivs_dict["du/dx"]**2 + params[1] * derivs_dict["d^2u/dx^2"] + params[2] * u * derivs_dict["du/dx"]**3
    string_form_of_the_equation = "du/dt = c[0] * du/dx^2 + c[1] * d^2u/dx^2 + c[2] * u * du/dx^3"
    len_of_params = 3
    return right_side, string_form_of_the_equation, len_of_params
```

This function takes in the inputs, including the second derivative in the derivs_dict dictionary, and uses the provided parameters to compute the right side of the equation. The resulting string_form_of_the_equation can be supplied to the evaluate function for comparing against the values of du/dt in the points_set data to get a score.