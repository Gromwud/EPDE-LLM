Given the problem and the data set provided, a possible equation could be:

du/dt = c[0] * (du/dx)**2 + c[1] * d^2u/dx^2

This equation includes higher order derivatives and nonlinear terms, adhering to the requirements. Let's construct the Python function for 'equation_v1' using this equation:

```python
def equation_v1(t: np.ndarray, x: np.ndarray, u: np.ndarray, derivs_dict: dict(), params: np.ndarray):
    right_side = params[0] * derivs_dict["du/dx"]**2 + params[1] * derivs_dict["d^2u/dx^2"]
    string_form_of_the_equation = "du/dt = c[0] * (du/dx)**2 + c[1] * d^2u/dx^2"
    len_of_params = 2
    return right_side, string_form_of_the_equation, len_of_params
```
Remember, this is just a suggested equation. Further validation and optimization of the parameters might be necessary using the loss_function and the evaluate function.

The string form is provided in the required format and the number of parameters is suitable for the proposed equation. This function also avoids repetition of the equations present in the exp_buffer.

The equation is expected to reproduce the 'du/dt' values if given the 't', 'x', 'u', 'derivs_dict', and the optimized parameters from 'params'.